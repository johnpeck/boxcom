\section{Firmware}

\subsection{Logger functions}

% logger_msg_p
\subsubsection{\texttt{logger\_msg\_p}}
\onecodeline{void logger_msg_p( char *logsys,
  logger_level_t loglevel, const char *logmsg, ... );
}
\textsl{Send a message to the logger module from permanent memory}  


\paragraph{Parameters}
\begin{itemize}
\item \texttt{logsys}
  \subitem Pointer to a string matching one of the logger system strings.
\item \texttt{loglevel}
  \subitem One of the logger level identifiers:
  \subsubitem \verb8log_level_ISR8 (lowest level)
  \subsubitem \verb8log_level_INFO8
  \subsubitem \verb8log_level_WARNING8
  \subsubitem \verb8log_level_ERROR8 (highest level)
\item \texttt{logmsg} \subitem Pointer to a string stored in
  permanent (flash) memory.  This might be a C format string.
\item \texttt{...} \textsl{(additional arguments)} 
  \subitem Depending on the format string, the function may expect a
  sequence of additional arguments, each containing a value to be used
  to replace a format specifier in the format string.  There should be
  at least as many of these arguments as the number of values
  specified in the format specifiers. Additional arguments are ignored
  by the function.
\end{itemize}

\paragraph{Examples}

\begin{center}
  \begin{minipage}[c]{\textwidth}
    \lstset{language=c,backgroundcolor=\color{codegray},
      showstringspaces=false,breaklines=false}
    \begin{lstlisting}
 logger_msg_p("command",log_level_INFO,
	      PSTR("Command '%s' recognized.\r\n"),command_array -> name);
    \end{lstlisting}
  \end{minipage}
\end{center}
Output (After receiving the \texttt{hello} command):
\boxcmd{[I](command) Command 'hello' recognized.}

